{"version":3,"file":"use-prevent-sticky-click-scroll.js","sourceRoot":"","sources":["../../../src/table/use-prevent-sticky-click-scroll.ts"],"names":[],"mappings":"AAAA,qEAAqE;AACrE,sCAAsC;;;AAEtC,OAAO,EAAE,SAAS,EAAE,MAAM,OAAO,CAAC;AAElC,OAAO,cAAc,MAAM,2BAA2B,CAAC;AAEvD,MAAM,kBAAkB,GAAG,IAAI,cAAc,CAAC,aAAa,CAAC,EAAE,CAAC;AAE/D,4DAA4D;AAC5D,mFAAmF;AACnF,uDAAuD;AACvD,MAAM,iBAAiB,GAAG,EAAE,CAAC;AAE7B,wHAAwH;AACxH,6BAA6B;AAC7B,iIAAiI;AACjI,oIAAoI;AACpI,mIAAmI;AACnI,+HAA+H;AAC/H,EAAE;AACF,0GAA0G;AAC1G,qHAAqH;AACrH,MAAM,UAAU,2BAA2B,CAAC,gBAAiD;IAC3F,SAAS,CAAC,GAAG,EAAE;QACb,IAAI,gBAAgB,CAAC,OAAO,EAAE;YAC5B,MAAM,SAAS,GAAG,gBAAgB,CAAC,OAAO,CAAC;YAC3C,MAAM,UAAU,GAAG,IAAI,UAAU,EAAE,CAAC;YAEpC,mFAAmF;YACnF,0EAA0E;YAC1E,gEAAgE;YAChE,MAAM,OAAO,GAAG,CAAC,KAAY,EAAE,EAAE;gBAC/B,IACE,KAAK,CAAC,MAAM;oBACZ,KAAK,CAAC,MAAM,YAAY,WAAW;oBACnC,CAAC,KAAK,CAAC,MAAM,CAAC,OAAO,CAAC,kBAAkB,CAAC,IAAI,KAAK,CAAC,MAAM,CAAC,OAAO,CAAC,kBAAkB,CAAC,CAAC,EACtF;oBACA,UAAU,CAAC,GAAG,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC;iBACtC;YACH,CAAC,CAAC;YACF,SAAS,CAAC,gBAAgB,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;YAE7C,6GAA6G;YAC7G,4GAA4G;YAC5G,6EAA6E;YAC7E,MAAM,QAAQ,GAAG,GAAG,EAAE;gBACpB,IAAI,UAAU,CAAC,MAAM,EAAE;oBACrB,SAAS,CAAC,UAAU,GAAG,UAAU,CAAC,UAAU,CAAC;oBAC7C,UAAU,CAAC,KAAK,EAAE,CAAC;iBACpB;YACH,CAAC,CAAC;YACF,SAAS,CAAC,gBAAgB,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;YAE/C,OAAO,GAAG,EAAE;gBACV,SAAS,CAAC,mBAAmB,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;gBAChD,SAAS,CAAC,mBAAmB,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;YACpD,CAAC,CAAC;SACH;IACH,CAAC,EAAE,CAAC,gBAAgB,CAAC,CAAC,CAAC;AACzB,CAAC;AAED,MAAM,UAAU;IAAhB;QACE,gCAAa,UAAU,CAAC,GAAG,EAAE,GAAE,CAAC,EAAE,CAAC,CAAC,EAAC;QACrC,iCAAc,CAAC,EAAC;QAChB,6BAAU,KAAK,EAAC;IAsBlB,CAAC;IApBQ,GAAG,CAAC,UAAkB;QAC3B,IAAI,CAAC,uBAAA,IAAI,0BAAQ,EAAE;YACjB,uBAAA,IAAI,sBAAW,IAAI,MAAA,CAAC;YACpB,uBAAA,IAAI,0BAAe,UAAU,MAAA,CAAC;YAC9B,uBAAA,IAAI,yBAAc,UAAU,CAAC,GAAG,EAAE,CAAC,CAAC,uBAAA,IAAI,sBAAW,KAAK,MAAA,CAAC,EAAE,iBAAiB,CAAC,MAAA,CAAC;SAC/E;IACH,CAAC;IAEM,KAAK;QACV,uBAAA,IAAI,sBAAW,KAAK,MAAA,CAAC;QACrB,YAAY,CAAC,uBAAA,IAAI,6BAAW,CAAC,CAAC;IAChC,CAAC;IAED,IAAW,MAAM;QACf,OAAO,uBAAA,IAAI,0BAAQ,CAAC;IACtB,CAAC;IAED,IAAW,UAAU;QACnB,OAAO,uBAAA,IAAI,8BAAY,CAAC;IAC1B,CAAC;CACF","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { useEffect } from 'react';\n\nimport bodyCellStyles from './body-cell/styles.css.js';\n\nconst stickyCellSelector = `.${bodyCellStyles['sticky-cell']}`;\n\n// The scroll lock timeout value was determined empirically.\n// It is small enough to not interfere with sequential user events, and long enough\n// to ensure the browser-triggered scroll event occurs.\nconst scrollLockTimeout = 50;\n\n// The function provides a workaround for a Chrome issue causing unexpected scroll when clicking on interactive elements\n// inside sticky table cells.\n// When an interactive element (cell editor button, row selector, or a custom interactive button or link) is clicked, it receives\n// focus. The browser then tries to ensure the focused element is visible on screen, and it scrolls the element into view as needed.\n// In Chrome, this scrolling also occurs when clicking an interactive element inside a sticky cell, despite it being fully visible.\n// This causes an unneeded and unexpected scroll of the table wrapper towards the sticky element (on the left or on the right).\n//\n// Note: If moving focus to an interactive element using the keyboard, the automatic scroll still happens.\n// That is because the implemented workaround is not suitable for focusin events due to a difference in events order.\nexport function usePreventStickyClickScroll(wrapperRefObject: React.RefObject<HTMLDivElement>) {\n  useEffect(() => {\n    if (wrapperRefObject.current) {\n      const wrapperEl = wrapperRefObject.current;\n      const scrollLock = new ScrollLock();\n\n      // For click events inside sticky cells we capture the table wrapper scroll offset.\n      // This is used to reset the browser-enforced scrolling that is to follow.\n      // The scroll lock is automatically cleared after a short delay.\n      const onClick = (event: Event) => {\n        if (\n          event.target &&\n          event.target instanceof HTMLElement &&\n          (event.target.matches(stickyCellSelector) || event.target.closest(stickyCellSelector))\n        ) {\n          scrollLock.set(wrapperEl.scrollLeft);\n        }\n      };\n      wrapperEl.addEventListener('click', onClick);\n\n      // We cannot prevent the browser-issued scroll events from happening, and cannot cancel the default behavior.\n      // Instead, if we detect a scroll event that immediately follows a click inside a sticky cell, we negate the\n      // effect of it by resetting the wrapper scroll offset to its previous value.\n      const onScroll = () => {\n        if (scrollLock.active) {\n          wrapperEl.scrollLeft = scrollLock.scrollLeft;\n          scrollLock.clear();\n        }\n      };\n      wrapperEl.addEventListener('scroll', onScroll);\n\n      return () => {\n        wrapperEl.removeEventListener('click', onClick);\n        wrapperEl.removeEventListener('scroll', onScroll);\n      };\n    }\n  }, [wrapperRefObject]);\n}\n\nclass ScrollLock {\n  #timeoutId = setTimeout(() => {}, 0);\n  #scrollLeft = 0;\n  #active = false;\n\n  public set(scrollLeft: number) {\n    if (!this.#active) {\n      this.#active = true;\n      this.#scrollLeft = scrollLeft;\n      this.#timeoutId = setTimeout(() => (this.#active = false), scrollLockTimeout);\n    }\n  }\n\n  public clear() {\n    this.#active = false;\n    clearTimeout(this.#timeoutId);\n  }\n\n  public get active() {\n    return this.#active;\n  }\n\n  public get scrollLeft() {\n    return this.#scrollLeft;\n  }\n}\n"]}