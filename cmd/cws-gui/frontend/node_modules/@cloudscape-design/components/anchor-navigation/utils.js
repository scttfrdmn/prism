// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import React from 'react';
import clsx from 'clsx';
import { AnchorItem } from './anchor-item';
import styles from './styles.css.js';
import testUtilsStyles from './test-classes/styles.css.js';
const collectChildItems = (items, currentIndex, currentLevel) => {
    const childItems = [];
    let nextIndex = currentIndex + 1;
    while (nextIndex < items.length && items[nextIndex].level > currentLevel) {
        childItems.push(items[nextIndex]);
        nextIndex++;
    }
    return childItems;
};
const createAnchorItem = (currentItem, index, childItems, renderQueue, context) => {
    const childList = [];
    const hasChildren = childItems.length > 0;
    const olClassNAme = clsx(styles['anchor-list'], testUtilsStyles['anchor-list']);
    if (hasChildren) {
        renderQueue.push({
            items: childItems,
            parentList: childList,
            startIndex: index + 1,
        });
    }
    return (React.createElement(AnchorItem, { onFollow: context.onFollowHandler, isActive: currentItem.href === context.currentActiveHref, key: index, index: index, anchor: currentItem }, hasChildren && React.createElement("ol", { className: olClassNAme }, childList)));
};
const processQueueItem = (items, startIndex, parentList, renderQueue, context) => {
    let currentIndex = 0;
    while (currentIndex < items.length) {
        const currentItem = items[currentIndex];
        const childItems = collectChildItems(items, currentIndex, currentItem.level);
        parentList.push(createAnchorItem(currentItem, startIndex + currentIndex, childItems, renderQueue, context));
        currentIndex += childItems.length + 1;
    }
};
// Perform a queue-based breadth-first traversal that groups child items under their parents based on level hierarchy.
export const renderNestedAnchors = (items, context) => {
    const rootList = [];
    const renderQueue = [];
    renderQueue.push({ items, parentList: rootList, startIndex: 0 });
    while (renderQueue.length > 0) {
        const currentItem = renderQueue.shift();
        processQueueItem(currentItem.items, currentItem.startIndex, currentItem.parentList, renderQueue, context);
    }
    return rootList;
};
//# sourceMappingURL=utils.js.map