"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.collectionReducer = collectionReducer;
exports.createActions = createActions;
exports.createSyncProps = createSyncProps;
const property_filter_js_1 = require("./operations/property-filter.js");
function collectionReducer(state, action) {
    const newState = Object.assign({}, state);
    switch (action.type) {
        case 'selection':
            newState.selectedItems = action.selectedItems;
            break;
        case 'expansion':
            newState.expandedItems = action.expandedItems;
            break;
        case 'filtering':
            newState.currentPageIndex = 1;
            newState.filteringText = action.filteringText;
            break;
        case 'sorting':
            newState.currentPageIndex = 1;
            newState.sortingState = action.sortingState;
            break;
        case 'pagination':
            newState.currentPageIndex = action.pageIndex;
            break;
        case 'property-filtering':
            newState.currentPageIndex = 1;
            newState.propertyFilteringQuery = action.query;
            break;
    }
    return newState;
}
function createActions({ dispatch, collectionRef, }) {
    return {
        setFiltering(filteringText) {
            var _a;
            dispatch({ type: 'filtering', filteringText });
            (_a = collectionRef.current) === null || _a === void 0 ? void 0 : _a.scrollToTop();
        },
        setSorting(state) {
            var _a;
            dispatch({ type: 'sorting', sortingState: state });
            (_a = collectionRef.current) === null || _a === void 0 ? void 0 : _a.scrollToTop();
        },
        setCurrentPage(pageIndex) {
            var _a;
            dispatch({ type: 'pagination', pageIndex });
            (_a = collectionRef.current) === null || _a === void 0 ? void 0 : _a.scrollToTop();
        },
        setSelectedItems(selectedItems) {
            dispatch({ type: 'selection', selectedItems });
        },
        setPropertyFiltering(query) {
            var _a;
            dispatch({ type: 'property-filtering', query });
            (_a = collectionRef.current) === null || _a === void 0 ? void 0 : _a.scrollToTop();
        },
        setExpandedItems(expandedItems) {
            dispatch({ type: 'expansion', expandedItems });
        },
    };
}
function createSyncProps(options, { filteringText, sortingState, selectedItems, expandedItems, currentPageIndex, propertyFilteringQuery, }, actions, collectionRef, { pagesCount, actualPageIndex, allItems, allPageItems, itemsTree, }) {
    var _a, _b, _c, _d, _e;
    let empty = options.filtering
        ? allItems.length
            ? options.filtering.noMatch
            : options.filtering.empty
        : null;
    empty = options.propertyFiltering
        ? allItems.length
            ? options.propertyFiltering.noMatch
            : options.propertyFiltering.empty
        : empty;
    const filteringOptions = options.propertyFiltering
        ? options.propertyFiltering.filteringProperties.reduce((acc, property) => {
            Object.keys(allItems.reduce((acc, item) => {
                acc['' + (0, property_filter_js_1.fixupFalsyValues)(item[property.key])] = true;
                return acc;
            }, {})).forEach(value => {
                if (value !== '') {
                    acc.push({
                        propertyKey: property.key,
                        value,
                    });
                }
            });
            return acc;
        }, [])
        : [];
    return {
        collectionProps: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ empty }, (options.sorting
            ? {
                onSortingChange: ({ detail }) => {
                    actions.setSorting(detail);
                },
                sortingColumn: sortingState === null || sortingState === void 0 ? void 0 : sortingState.sortingColumn,
                sortingDescending: sortingState === null || sortingState === void 0 ? void 0 : sortingState.isDescending,
            }
            : {})), (options.expandableRows
            ? {
                expandableRows: {
                    getItemChildren(item) {
                        return itemsTree.getChildren(item);
                    },
                    isItemExpandable(item) {
                        return itemsTree.getChildren(item).length > 0;
                    },
                    expandedItems,
                    onExpandableItemToggle: ({ detail: { item, expanded } }) => {
                        const getId = options.expandableRows.getId;
                        if (expanded) {
                            for (const stateItem of expandedItems) {
                                if (getId(stateItem) === getId(item)) {
                                    return;
                                }
                            }
                            actions.setExpandedItems([...expandedItems, item]);
                        }
                        else {
                            actions.setExpandedItems(expandedItems.filter(stateItem => getId(stateItem) !== getId(item)));
                        }
                    },
                },
                // The trackBy property is used to match expanded items by ID and not by object reference.
                // The property can be overridden by the explicitly provided selection.trackBy.
                // If that is the case, we assume both selection.trackBy and expandableRows.getId have the same result.
                // If not, the expandable state won't be matched correctly by the table.
                trackBy: options.expandableRows.getId,
            }
            : {})), (options.selection
            ? {
                onSelectionChange: ({ detail: { selectedItems } }) => {
                    actions.setSelectedItems(selectedItems);
                },
                selectedItems,
                trackBy: (_a = options.selection.trackBy) !== null && _a !== void 0 ? _a : (_b = options.expandableRows) === null || _b === void 0 ? void 0 : _b.getId,
            }
            : {})), { ref: collectionRef, firstIndex: 1, totalItemsCount: allPageItems.length }), (((_c = options.pagination) === null || _c === void 0 ? void 0 : _c.pageSize)
            ? {
                firstIndex: ((actualPageIndex !== null && actualPageIndex !== void 0 ? actualPageIndex : currentPageIndex) - 1) * options.pagination.pageSize + 1,
            }
            : {})),
        filterProps: {
            filteringText,
            onChange: ({ detail: { filteringText } }) => {
                actions.setFiltering(filteringText);
            },
        },
        propertyFilterProps: {
            query: propertyFilteringQuery,
            onChange: ({ detail: query }) => {
                actions.setPropertyFiltering(query);
            },
            filteringProperties: ((_d = options.propertyFiltering) === null || _d === void 0 ? void 0 : _d.filteringProperties) || [],
            filteringOptions,
            freeTextFiltering: (_e = options.propertyFiltering) === null || _e === void 0 ? void 0 : _e.freeTextFiltering,
        },
        paginationProps: {
            currentPageIndex: actualPageIndex !== null && actualPageIndex !== void 0 ? actualPageIndex : currentPageIndex,
            // pagesCount is always calculated when options.pagination is present
            pagesCount: pagesCount,
            onChange: ({ detail: { currentPageIndex } }) => {
                actions.setCurrentPage(currentPageIndex);
            },
        },
    };
}
