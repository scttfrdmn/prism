"use strict";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.ItemsTree = void 0;
class ItemsTree {
    constructor(items, treeProps) {
        var _a;
        this.size = 0;
        this.hasNesting = false;
        this.roots = new Array();
        this.idToChildren = new Map();
        this.filter = (predicate) => {
            if (!this.hasNesting) {
                this.items = this.items.filter(predicate);
                this.size = this.items.length;
            }
            else {
                this.filterTree(predicate);
            }
            return this;
        };
        this.sort = (comparator) => {
            if (!this.hasNesting) {
                this.items = this.items.slice().sort(comparator);
            }
            else {
                this.sortTree(comparator);
            }
            return this;
        };
        this.getChildren = (item) => {
            var _a;
            return (_a = (this.treeProps && this.idToChildren.get(this.treeProps.getId(item)))) !== null && _a !== void 0 ? _a : [];
        };
        this.getItems = () => {
            if (this.hasNesting) {
                return this.roots;
            }
            return this.items;
        };
        this.getSize = () => {
            return this.size;
        };
        this.filterTree = (predicate) => {
            const filterNode = (item) => {
                const children = this.getChildren(item);
                const filteredChildren = children.filter(filterNode);
                this.size -= children.length - filteredChildren.length;
                this.setChildren(item, filteredChildren);
                return predicate(item) || filteredChildren.length > 0;
            };
            const roots = this.roots;
            this.roots = this.roots.filter(filterNode);
            this.size -= roots.length - this.roots.length;
        };
        this.sortTree = (comparator) => {
            const sortLevel = (items) => {
                items.sort(comparator);
                for (const item of items) {
                    sortLevel(this.getChildren(item));
                }
            };
            sortLevel(this.roots);
        };
        this.size = items.length;
        this.items = items;
        this.treeProps = treeProps;
        if (!treeProps) {
            return;
        }
        // Assign item children.
        for (const item of items) {
            const parentId = treeProps.getParentId(item);
            if (parentId === null) {
                this.roots.push(item);
            }
            else {
                const children = (_a = this.idToChildren.get(parentId)) !== null && _a !== void 0 ? _a : [];
                children.push(item);
                this.idToChildren.set(parentId, children);
                this.hasNesting = true;
            }
        }
        // Assign item levels.
        const traverse = (item, level = 1) => {
            var _a;
            for (const child of (_a = this.idToChildren.get(treeProps.getId(item))) !== null && _a !== void 0 ? _a : []) {
                traverse(child, level + 1);
            }
        };
        this.roots.forEach(root => traverse(root));
    }
    setChildren(item, children) {
        if (this.treeProps) {
            this.idToChildren.set(this.treeProps.getId(item), children);
        }
    }
}
exports.ItemsTree = ItemsTree;
