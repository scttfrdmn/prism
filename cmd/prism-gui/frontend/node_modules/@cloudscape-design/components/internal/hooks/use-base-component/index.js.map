{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../../src/internal/hooks/use-base-component/index.ts"],"names":[],"mappings":"AAIA,OAAO,EAEL,oBAAoB,EACpB,mBAAmB,EACnB,eAAe,GAChB,MAAM,+CAA+C,CAAC;AAGvD,OAAO,EAAE,cAAc,EAAE,eAAe,EAAE,KAAK,EAAE,MAAM,mBAAmB,CAAC;AAC3E,OAAO,EAAE,cAAc,EAAE,MAAM,8BAA8B,CAAC;AAC9D,OAAO,EAAE,gBAAgB,EAAE,MAAM,oBAAoB,CAAC;AACtD,OAAO,EAAE,qBAAqB,EAAE,MAAM,gBAAgB,CAAC;AAUvD;;;;GAIG;AACH,MAAM,CAAC,OAAO,UAAU,gBAAgB,CACtC,aAAqB,EACrB,MAA+B,EAC/B,iBAAqC;IAErC,MAAM,eAAe,GAAG,gBAAgB,EAAE,CAAC;IAC3C,MAAM,KAAK,GAAG,cAAc,CAAC,KAAK,EAAE,eAAe,CAAC,CAAC;IACrD,mBAAmB,CAAC,aAAa,EAAE,EAAE,aAAa,EAAE,cAAc,EAAE,cAAc,EAAE,eAAe,EAAE,KAAK,EAAE,EAAE,MAAM,CAAC,CAAC;IACtH,MAAM,UAAU,GAAG,oBAAoB,CACrC,aAAa,EACb,EAAE,WAAW,EAAE,cAAc,EAAE,OAAO,EAAE,eAAe,EAAE,KAAK,EAAE,EAChE,iBAAwB,CACzB,CAAC;IACF,qBAAqB,CAAC,UAAU,CAAC,CAAC;IAClC,eAAe,CAAC,UAAU,CAAC,CAAC;IAC5B,OAAO,EAAE,iBAAiB,EAAE,UAAU,EAAE,CAAC;AAC3C,CAAC","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React from 'react';\n\nimport {\n  ComponentConfiguration,\n  useComponentMetadata,\n  useComponentMetrics,\n  useFocusVisible,\n} from '@cloudscape-design/component-toolkit/internal';\n\nimport { AnalyticsMetadata } from '../../analytics/interfaces';\nimport { PACKAGE_SOURCE, PACKAGE_VERSION, THEME } from '../../environment';\nimport { getVisualTheme } from '../../utils/get-visual-theme';\nimport { useVisualRefresh } from '../use-visual-mode';\nimport { useMissingStylesCheck } from './styles-check';\n\nexport interface InternalBaseComponentProps {\n  // Typescript requires Ref type to be exact DOM element type it is assigned to, e.g. HTMLDivElement\n  // Typical community practice is explicit type casting: https://stackoverflow.com/questions/61102101/cannot-assign-refobjecthtmldivelement-to-refobjecthtmlelement-instance\n  // To avoid doing this, we use any to skip type checks. Treat this type as pass through, never\n  // read `__internalRootRef.current`, use your own refs if you need\n  __internalRootRef?: React.Ref<any>;\n}\n\n/**\n * This hook is used for components which are exported to customers. The returned __internalRootRef needs to be\n * attached to the (internal) component's root DOM node. The hook takes care of attaching the metadata to this\n * root DOM node and emits the telemetry for this component.\n */\nexport default function useBaseComponent(\n  componentName: string,\n  config?: ComponentConfiguration,\n  analyticsMetadata?: AnalyticsMetadata\n) {\n  const isVisualRefresh = useVisualRefresh();\n  const theme = getVisualTheme(THEME, isVisualRefresh);\n  useComponentMetrics(componentName, { packageSource: PACKAGE_SOURCE, packageVersion: PACKAGE_VERSION, theme }, config);\n  const elementRef = useComponentMetadata(\n    componentName,\n    { packageName: PACKAGE_SOURCE, version: PACKAGE_VERSION, theme },\n    analyticsMetadata as any\n  );\n  useMissingStylesCheck(elementRef);\n  useFocusVisible(elementRef);\n  return { __internalRootRef: elementRef };\n}\n"]}