{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../../src/internal/hooks/use-intersection-observer/index.ts"],"names":[],"mappings":"AAAA,qEAAqE;AACrE,sCAAsC;AAEtC,OAAO,EAAe,WAAW,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,OAAO,CAAC;AAMnE;;;GAGG;AACH,MAAM,UAAU,uBAAuB,CAAwB,EAC7D,YAAY,GAAG,KAAK,MACa,EAAE;IACnC,MAAM,WAAW,GAAG,MAAM,CAA8B,IAAI,CAAC,CAAC;IAC9D,MAAM,CAAC,cAAc,EAAE,iBAAiB,CAAC,GAAG,QAAQ,CAAC,YAAY,CAAC,CAAC;IAEnE,MAAM,GAAG,GAAG,WAAW,CAAiB,aAAa,CAAC,EAAE;QACtD,IAAI,OAAO,oBAAoB,KAAK,WAAW,EAAE;YAC/C,wCAAwC;YACxC,OAAO;SACR;QAED,IAAI,WAAW,CAAC,OAAO,EAAE;YACvB,uDAAuD;YACvD,WAAW,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC;SAClC;QAED,gDAAgD;QAChD,IAAI,aAAa,EAAE;YACjB,4EAA4E;YAC5E,iFAAiF;YACjF,2FAA2F;YAC3F,IAAI,4BAA4B,GAAG,oBAAoB,CAAC;YACxD,IAAI;gBACF,IAAI,MAAM,CAAC,GAAG,EAAE;oBACd,4BAA4B,GAAI,MAAM,CAAC,GAAqB,CAAC,oBAAoB,CAAC;iBACnF;aACF;YAAC,WAAM;gBACN,oFAAoF;aACrF;YACD,WAAW,CAAC,OAAO,GAAG,IAAI,4BAA4B,CAAC,OAAO,CAAC,EAAE;gBAC/D,IAAI,WAAW,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;gBAC7B,KAAK,MAAM,KAAK,IAAI,OAAO,EAAE;oBAC3B,IAAI,KAAK,CAAC,IAAI,GAAG,WAAW,CAAC,IAAI,EAAE;wBACjC,WAAW,GAAG,KAAK,CAAC;qBACrB;iBACF;gBACD,iBAAiB,CAAC,WAAW,CAAC,cAAc,CAAC,CAAC;YAChD,CAAC,CAAC,CAAC;YACH,WAAW,CAAC,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;SAC5C;IACH,CAAC,EAAE,EAAE,CAAC,CAAC;IAEP,OAAO,EAAE,GAAG,EAAE,cAAc,EAAE,CAAC;AACjC,CAAC","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { RefCallback, useCallback, useRef, useState } from 'react';\n\ninterface UseIntersectionObserverConfig {\n  initialState?: boolean;\n}\n\n/**\n * A hook that uses an Intersection Observer on the target element ref\n * and detects if the element is intersecting with its parent.\n */\nexport function useIntersectionObserver<T extends HTMLElement>({\n  initialState = false,\n}: UseIntersectionObserverConfig = {}) {\n  const observerRef = useRef<IntersectionObserver | null>(null);\n  const [isIntersecting, setIsIntersecting] = useState(initialState);\n\n  const ref = useCallback<RefCallback<T>>(targetElement => {\n    if (typeof IntersectionObserver === 'undefined') {\n      // Do nothing in environments like JSDOM\n      return;\n    }\n\n    if (observerRef.current) {\n      // Dismiss previous observer because the target changed\n      observerRef.current.disconnect();\n    }\n\n    // Create a new observer with the target element\n    if (targetElement) {\n      // Fix for AWSUI-60898: In Firefox, IntersectionObserver instances inside an\n      //   iframe context can't detect visibility changes caused by changes to elements\n      //   outside the iframe (e.g. if an element wrapping the iframe is set to `display: none`).\n      let TopLevelIntersectionObserver = IntersectionObserver;\n      try {\n        if (window.top) {\n          TopLevelIntersectionObserver = (window.top as typeof window).IntersectionObserver;\n        }\n      } catch {\n        // Tried to access a cross-origin iframe. Fall back to current IntersectionObserver.\n      }\n      observerRef.current = new TopLevelIntersectionObserver(entries => {\n        let latestEntry = entries[0];\n        for (const entry of entries) {\n          if (entry.time > latestEntry.time) {\n            latestEntry = entry;\n          }\n        }\n        setIsIntersecting(latestEntry.isIntersecting);\n      });\n      observerRef.current.observe(targetElement);\n    }\n  }, []);\n\n  return { ref, isIntersecting };\n}\n"]}