// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import { SYSTEM } from '../internal/environment';
import { getComputedAbstractSwitchState } from '../internal/utils/style';
export function getAbstractSwitchStyles(style, checked, disabled, readOnly, indeterminate) {
    var _a, _b, _c, _d, _e, _f, _g;
    let properties = {};
    if (SYSTEM === 'core' && ((style === null || style === void 0 ? void 0 : style.label) || (style === null || style === void 0 ? void 0 : style.input))) {
        const computedState = getComputedAbstractSwitchState(checked, disabled, readOnly, indeterminate);
        properties = {
            label: {
                color: ((_a = style === null || style === void 0 ? void 0 : style.label) === null || _a === void 0 ? void 0 : _a.color) && style.label.color[computedState],
            },
            focusRing: {
                borderColor: (_c = (_b = style === null || style === void 0 ? void 0 : style.input) === null || _b === void 0 ? void 0 : _b.focusRing) === null || _c === void 0 ? void 0 : _c.borderColor,
                borderRadius: (_e = (_d = style === null || style === void 0 ? void 0 : style.input) === null || _d === void 0 ? void 0 : _d.focusRing) === null || _e === void 0 ? void 0 : _e.borderRadius,
                borderWidth: (_g = (_f = style === null || style === void 0 ? void 0 : style.input) === null || _f === void 0 ? void 0 : _f.focusRing) === null || _g === void 0 ? void 0 : _g.borderWidth,
            },
        };
    }
    return properties;
}
export function getCheckboxIconStyles(style, checked, disabled, readOnly, indeterminate) {
    var _a, _b, _c, _d;
    let properties = {};
    if (SYSTEM === 'core' && (style === null || style === void 0 ? void 0 : style.input)) {
        const computedState = getComputedAbstractSwitchState(checked, disabled, readOnly, indeterminate);
        properties = {
            box: {
                fill: ((_a = style.input) === null || _a === void 0 ? void 0 : _a.fill) && style.input.fill[computedState],
                stroke: ((_b = style.input) === null || _b === void 0 ? void 0 : _b.stroke) && style.input.stroke[computedState],
            },
            line: {
                stroke: ((_d = (_c = style.input) === null || _c === void 0 ? void 0 : _c.check) === null || _d === void 0 ? void 0 : _d.stroke) &&
                    style.input.check.stroke[computedState],
            },
        };
    }
    return properties;
}
//# sourceMappingURL=style.js.map