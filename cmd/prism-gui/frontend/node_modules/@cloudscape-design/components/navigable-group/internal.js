import { __rest } from "tslib";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import React, { forwardRef, useEffect, useImperativeHandle, useRef } from 'react';
import clsx from 'clsx';
import { useMergeRefs } from '@cloudscape-design/component-toolkit/internal';
import { SingleTabStopNavigationProvider, } from '@cloudscape-design/component-toolkit/internal';
import { getBaseProps } from '../internal/base-component';
import { getAllFocusables } from '../internal/components/focus-lock/utils';
import { hasModifierKeys } from '../internal/events';
import { KeyCode } from '../internal/keycode';
import { circleIndex } from '../internal/utils/circle-index';
import handleKey from '../internal/utils/handle-key';
import styles from './styles.css.js';
import testUtilStyles from './test-classes/styles.css.js';
const InternalNavigableGroup = forwardRef((_a, ref) => {
    var { children, getItemKey, navigationDirection = 'horizontal', __internalRootRef } = _a, props = __rest(_a, ["children", "getItemKey", "navigationDirection", "__internalRootRef"]);
    const baseProps = getBaseProps(props);
    const navigationAPI = useRef(null);
    const containerObjectRef = useRef(null);
    const containerRef = useMergeRefs(containerObjectRef, __internalRootRef);
    const focusedIdRef = useRef();
    useImperativeHandle(ref, () => ({
        focus: () => {
            const target = getNextFocusTarget();
            if (target) {
                target.focus();
            }
        },
    }));
    function getNextFocusTarget() {
        var _a, _b;
        if (containerObjectRef.current) {
            const focusables = getFocusablesFrom(containerObjectRef.current);
            return (_b = (_a = focusables.find(el => getItemKey(el) === focusedIdRef.current)) !== null && _a !== void 0 ? _a : focusables[0]) !== null && _b !== void 0 ? _b : null;
        }
        return null;
    }
    function onUnregisterActive(focusableElement) {
        var _a;
        // Only refocus when the node is actually removed (no such element anymore).
        const target = (_a = navigationAPI.current) === null || _a === void 0 ? void 0 : _a.getFocusTarget();
        if (target && getItemKey(target) !== getItemKey(focusableElement)) {
            target.focus();
        }
    }
    useEffect(() => {
        var _a;
        (_a = navigationAPI.current) === null || _a === void 0 ? void 0 : _a.updateFocusTarget();
    });
    function onFocus(event) {
        var _a, _b;
        if (event.target instanceof HTMLElement && ((_a = navigationAPI.current) === null || _a === void 0 ? void 0 : _a.isRegistered(event.target))) {
            focusedIdRef.current = getItemKey(event.target);
        }
        (_b = navigationAPI.current) === null || _b === void 0 ? void 0 : _b.updateFocusTarget();
    }
    function onBlur() {
        var _a;
        (_a = navigationAPI.current) === null || _a === void 0 ? void 0 : _a.updateFocusTarget();
    }
    function onKeyDown(event) {
        var _a, _b;
        const focusTarget = (_a = navigationAPI.current) === null || _a === void 0 ? void 0 : _a.getFocusTarget();
        let specialKeys = [];
        switch (navigationDirection) {
            case 'horizontal':
                specialKeys = [KeyCode.right, KeyCode.left];
                break;
            case 'vertical':
                specialKeys = [KeyCode.down, KeyCode.up];
                break;
            case 'both':
                specialKeys = [KeyCode.right, KeyCode.left, KeyCode.down, KeyCode.up];
                break;
        }
        specialKeys.push(KeyCode.end, KeyCode.home, KeyCode.pageUp, KeyCode.pageDown);
        if (hasModifierKeys(event) || specialKeys.indexOf(event.keyCode) === -1) {
            return;
        }
        if (!containerObjectRef.current || !focusTarget) {
            return;
        }
        // Ignore navigation when the focused element is not a registered focusable.
        if (document.activeElement && !((_b = navigationAPI.current) === null || _b === void 0 ? void 0 : _b.isRegistered(document.activeElement))) {
            return;
        }
        event.preventDefault();
        const focusables = getFocusablesFrom(containerObjectRef.current);
        const activeIndex = focusables.indexOf(focusTarget);
        const getNextIndex = (delta) => {
            const newIndex = activeIndex + delta;
            return circleIndex(newIndex, [0, focusables.length - 1]);
        };
        handleKey(event, {
            onHome: () => focusElement(focusables[0]),
            onEnd: () => focusElement(focusables[focusables.length - 1]),
            onInlineStart: () => focusElement(focusables[getNextIndex(-1)]),
            onBlockStart: () => focusElement(focusables[getNextIndex(-1)]),
            onInlineEnd: () => focusElement(focusables[getNextIndex(1)]),
            onBlockEnd: () => focusElement(focusables[getNextIndex(1)]),
        });
    }
    function focusElement(element) {
        element.focus();
    }
    // List all non-disabled and registered focusables: those are eligible for keyboard navigation.
    function getFocusablesFrom(target) {
        function isElementRegistered(element) {
            var _a, _b;
            return (_b = (_a = navigationAPI.current) === null || _a === void 0 ? void 0 : _a.isRegistered(element)) !== null && _b !== void 0 ? _b : false;
        }
        function isElementDisabled(element) {
            if ('disabled' in element) {
                return element.disabled;
            }
            return false;
        }
        return getAllFocusables(target).filter(el => isElementRegistered(el) && !isElementDisabled(el));
    }
    return (React.createElement("div", Object.assign({}, baseProps, { className: clsx(styles.root, testUtilStyles.root, baseProps.className), ref: containerRef, onFocus: onFocus, onBlur: onBlur, onKeyDown: onKeyDown }),
        React.createElement(SingleTabStopNavigationProvider, { ref: navigationAPI, navigationActive: true, getNextFocusTarget: getNextFocusTarget, onUnregisterActive: onUnregisterActive }, children)));
});
export default InternalNavigableGroup;
//# sourceMappingURL=internal.js.map