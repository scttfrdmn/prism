// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import { joinDateTime, splitDateTime } from '../internal/utils/date-time';
import { isIsoDateOnly, isIsoMonthOnly } from '../internal/utils/date-time';
import { normalizeTimeString } from '../internal/utils/date-time/join-date-time';
import { setTimeOffset, shiftTimeOffset } from './time-offset';
function isAbsoluteValue(value) {
    return value !== null && (value === null || value === void 0 ? void 0 : value.type) === 'absolute';
}
function isEmptyAbsoluteValue(value) {
    return value.type === 'absolute' && value.startDate === '' && value.endDate === '';
}
function isDateOrMonthOnly(value, checkFn) {
    return checkFn(value.startDate) && checkFn(value.endDate);
}
export function formatValue(value, { timeOffset, monthOnly, dateOnly, }) {
    if (!isAbsoluteValue(value) || isEmptyAbsoluteValue(value)) {
        return value;
    }
    if (monthOnly || dateOnly) {
        const [startPart, endPart] = [value.startDate, value.endDate].map(date => 
        //strip out time or day+time text from dates
        monthOnly ? date.split('T')[0].split('-').slice(0, 2).join('-') : date.split('T')[0]);
        return { type: 'absolute', startDate: startPart, endDate: endPart };
    }
    return setTimeOffset(value, timeOffset === null
        ? {
            startDate: undefined,
            endDate: undefined,
        }
        : timeOffset);
}
export function getDefaultMode(value, relativeOptions, rangeSelectorMode) {
    if (value === null || value === void 0 ? void 0 : value.type) {
        return value.type;
    }
    if (rangeSelectorMode === 'relative-only') {
        return 'relative';
    }
    if (rangeSelectorMode === 'absolute-only') {
        return 'absolute';
    }
    return relativeOptions.length > 0 ? 'relative' : 'absolute';
}
export function splitAbsoluteValue(value, hideTime = false) {
    if (!value) {
        return { start: { date: '', time: '' }, end: { date: '', time: '' } };
    }
    return {
        start: Object.assign(Object.assign({}, splitDateTime(value.startDate)), (hideTime ? { time: '' } : {})),
        end: Object.assign(Object.assign({}, splitDateTime(value.endDate)), (hideTime ? { time: '' } : {})),
    };
}
export function joinAbsoluteValue(value, hideTime = false) {
    const [startTime, endTime] = [value.start.time || '00:00:00', value.end.time || '23:59:59'].map(normalizeTimeString);
    return {
        type: 'absolute',
        startDate: hideTime ? value.start.date : joinDateTime(value.start.date, startTime),
        endDate: hideTime ? value.end.date : joinDateTime(value.end.date, endTime),
    };
}
export function formatInitialValue(value, dateOnly, monthOnly, normalizedTimeOffset) {
    if (!isAbsoluteValue(value)) {
        return shiftTimeOffset(value, normalizedTimeOffset);
    }
    if (isEmptyAbsoluteValue(value)) {
        return value;
    }
    if (dateOnly || monthOnly) {
        return formatValue(value, { dateOnly, monthOnly, timeOffset: normalizedTimeOffset });
    }
    if (isDateOrMonthOnly(value, isIsoDateOnly) || isDateOrMonthOnly(value, isIsoMonthOnly)) {
        return value;
    }
    return shiftTimeOffset(value, normalizedTimeOffset);
}
//# sourceMappingURL=utils.js.map