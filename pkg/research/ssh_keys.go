package research

import (
	"crypto/ed25519"
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"encoding/pem"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"golang.org/x/crypto/ssh"
)

// SSHKeyManager handles SSH key generation, storage, and distribution for research users
type SSHKeyManager struct {
	keyStore KeyStore
	keyGen   KeyGenerator
	basePath string
}

// NewSSHKeyManager creates a new SSH key manager
func NewSSHKeyManager(basePath string) *SSHKeyManager {
	return &SSHKeyManager{
		keyStore: &FileKeyStore{basePath: basePath},
		keyGen:   &DefaultKeyGenerator{},
		basePath: basePath,
	}
}

// GenerateSSHKeyPair generates a new SSH key pair for a research user
func (skm *SSHKeyManager) GenerateSSHKeyPair(profileID, username, keyType string) (*SSHKeyConfig, []byte, error) {
	// Determine key size based on type
	var keySize int
	switch keyType {
	case "rsa":
		keySize = 2048
	case "ed25519":
		keySize = 0 // Ed25519 doesn't use key size
	default:
		return nil, nil, fmt.Errorf("unsupported key type: %s", keyType)
	}

	// Generate key pair
	privateKey, publicKey, err := skm.keyGen.GenerateKeyPair(keyType, keySize)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to generate key pair: %w", err)
	}

	// Get fingerprint
	fingerprint, err := skm.keyGen.GetFingerprint(publicKey)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to get fingerprint: %w", err)
	}

	// Create key ID
	keyID := fmt.Sprintf("%s-%s-%d", username, keyType, time.Now().Unix())

	// Create key config
	keyConfig := &SSHKeyConfig{
		KeyID:         keyID,
		Fingerprint:   fingerprint,
		PublicKey:     string(publicKey),
		Comment:       fmt.Sprintf("%s@cloudworkstation-%s", username, profileID),
		CreatedAt:     time.Now(),
		FromProfile:   profileID,
		AutoGenerated: true,
	}

	// Store public key
	if err := skm.keyStore.StorePublicKey(profileID, username, keyID, publicKey); err != nil {
		return nil, nil, fmt.Errorf("failed to store public key: %w", err)
	}

	return keyConfig, privateKey, nil
}

// ImportSSHPublicKey imports an existing SSH public key for a research user
func (skm *SSHKeyManager) ImportSSHPublicKey(profileID, username, publicKeyData, comment string) (*SSHKeyConfig, error) {
	// Validate public key
	publicKeyBytes := []byte(publicKeyData)
	if err := skm.keyGen.ValidatePublicKey(publicKeyBytes); err != nil {
		return nil, fmt.Errorf("invalid public key: %w", err)
	}

	// Get fingerprint
	fingerprint, err := skm.keyGen.GetFingerprint(publicKeyBytes)
	if err != nil {
		return nil, fmt.Errorf("failed to get fingerprint: %w", err)
	}

	// Create key ID from fingerprint
	keyID := fmt.Sprintf("imported-%s", fingerprint[:8])

	// Create key config
	keyConfig := &SSHKeyConfig{
		KeyID:         keyID,
		Fingerprint:   fingerprint,
		PublicKey:     publicKeyData,
		Comment:       comment,
		CreatedAt:     time.Now(),
		FromProfile:   profileID,
		AutoGenerated: false,
	}

	// Store public key
	if err := skm.keyStore.StorePublicKey(profileID, username, keyID, publicKeyBytes); err != nil {
		return nil, fmt.Errorf("failed to store public key: %w", err)
	}

	return keyConfig, nil
}

// GetPublicKeysForUser retrieves all public keys for a research user
func (skm *SSHKeyManager) GetPublicKeysForUser(profileID, username string) (map[string]*SSHKeyConfig, error) {
	publicKeys, err := skm.keyStore.GetPublicKeys(profileID, username)
	if err != nil {
		return nil, fmt.Errorf("failed to get public keys: %w", err)
	}

	configs := make(map[string]*SSHKeyConfig)
	for keyID, publicKey := range publicKeys {
		// Load key config
		config, err := skm.loadKeyConfig(profileID, username, keyID)
		if err != nil {
			// Create basic config if metadata is missing
			fingerprint, _ := skm.keyGen.GetFingerprint(publicKey)
			config = &SSHKeyConfig{
				KeyID:       keyID,
				Fingerprint: fingerprint,
				PublicKey:   string(publicKey),
				Comment:     "imported",
				CreatedAt:   time.Now(),
				FromProfile: profileID,
			}
		}
		configs[keyID] = config
	}

	return configs, nil
}

// GetAuthorizedKeysContent generates authorized_keys file content for a research user
func (skm *SSHKeyManager) GetAuthorizedKeysContent(profileID, username string) (string, error) {
	keyConfigs, err := skm.GetPublicKeysForUser(profileID, username)
	if err != nil {
		return "", fmt.Errorf("failed to get public keys: %w", err)
	}

	var lines []string
	for _, config := range keyConfigs {
		// Format: ssh-rsa AAAAB3... comment
		line := config.PublicKey
		if config.Comment != "" && !strings.Contains(config.PublicKey, config.Comment) {
			line = fmt.Sprintf("%s %s", strings.TrimSpace(config.PublicKey), config.Comment)
		}
		lines = append(lines, line)
	}

	return strings.Join(lines, "\n"), nil
}

// DeletePublicKey removes a public key for a research user
func (skm *SSHKeyManager) DeletePublicKey(profileID, username, keyID string) error {
	if err := skm.keyStore.DeletePublicKey(profileID, username, keyID); err != nil {
		return fmt.Errorf("failed to delete public key: %w", err)
	}

	// Also remove key config metadata
	configPath := skm.getKeyConfigPath(profileID, username, keyID)
	if err := os.Remove(configPath); err != nil && !os.IsNotExist(err) {
		// Log warning but don't fail
		fmt.Printf("Warning: Failed to remove key config %s: %v\n", configPath, err)
	}

	return nil
}

// UpdateKeyUsage updates the last used timestamp for a key
func (skm *SSHKeyManager) UpdateKeyUsage(profileID, username, keyID string) error {
	config, err := skm.loadKeyConfig(profileID, username, keyID)
	if err != nil {
		return fmt.Errorf("failed to load key config: %w", err)
	}

	now := time.Now()
	config.LastUsed = &now

	return skm.saveKeyConfig(profileID, username, keyID, config)
}

// ListKeyFingerprints returns a list of key fingerprints for a user
func (skm *SSHKeyManager) ListKeyFingerprints(profileID, username string) ([]string, error) {
	return skm.keyStore.ListKeyFingerprints(profileID, username)
}

// Private helper methods

func (skm *SSHKeyManager) loadKeyConfig(profileID, username, keyID string) (*SSHKeyConfig, error) {
	configPath := skm.getKeyConfigPath(profileID, username, keyID)

	data, err := os.ReadFile(configPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read key config: %w", err)
	}

	var config SSHKeyConfig
	if err := json.Unmarshal(data, &config); err != nil {
		return nil, fmt.Errorf("failed to unmarshal key config: %w", err)
	}

	return &config, nil
}

func (skm *SSHKeyManager) saveKeyConfig(profileID, username, keyID string, config *SSHKeyConfig) error {
	configPath := skm.getKeyConfigPath(profileID, username, keyID)
	configDir := filepath.Dir(configPath)

	// Create directory if it doesn't exist
	if err := os.MkdirAll(configDir, 0755); err != nil {
		return fmt.Errorf("failed to create config directory: %w", err)
	}

	data, err := json.MarshalIndent(config, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal key config: %w", err)
	}

	if err := os.WriteFile(configPath, data, 0600); err != nil {
		return fmt.Errorf("failed to write key config: %w", err)
	}

	return nil
}

func (skm *SSHKeyManager) getKeyConfigPath(profileID, username, keyID string) string {
	return filepath.Join(skm.basePath, "ssh-keys", profileID, username, keyID+".json")
}

// FileKeyStore implements KeyStore interface using filesystem storage
type FileKeyStore struct {
	basePath string
}

// StorePublicKey stores a public key to the filesystem
func (fks *FileKeyStore) StorePublicKey(profileID, username, keyID string, publicKey []byte) error {
	keyPath := fks.getPublicKeyPath(profileID, username, keyID)
	keyDir := filepath.Dir(keyPath)

	// Create directory if it doesn't exist
	if err := os.MkdirAll(keyDir, 0755); err != nil {
		return fmt.Errorf("failed to create key directory: %w", err)
	}

	// Write public key
	if err := os.WriteFile(keyPath, publicKey, 0644); err != nil {
		return fmt.Errorf("failed to write public key: %w", err)
	}

	return nil
}

// GetPublicKeys retrieves all public keys for a user
func (fks *FileKeyStore) GetPublicKeys(profileID, username string) (map[string][]byte, error) {
	userDir := filepath.Join(fks.basePath, "ssh-keys", profileID, username)

	entries, err := os.ReadDir(userDir)
	if err != nil {
		if os.IsNotExist(err) {
			return make(map[string][]byte), nil
		}
		return nil, fmt.Errorf("failed to read user key directory: %w", err)
	}

	keys := make(map[string][]byte)
	for _, entry := range entries {
		if entry.IsDir() || !strings.HasSuffix(entry.Name(), ".pub") {
			continue
		}

		keyID := strings.TrimSuffix(entry.Name(), ".pub")
		keyPath := filepath.Join(userDir, entry.Name())

		publicKey, err := os.ReadFile(keyPath)
		if err != nil {
			continue // Skip invalid keys
		}

		keys[keyID] = publicKey
	}

	return keys, nil
}

// DeletePublicKey removes a public key from storage
func (fks *FileKeyStore) DeletePublicKey(profileID, username, keyID string) error {
	keyPath := fks.getPublicKeyPath(profileID, username, keyID)
	if err := os.Remove(keyPath); err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("failed to delete public key: %w", err)
	}
	return nil
}

// ListKeyFingerprints returns fingerprints for all keys for a user
func (fks *FileKeyStore) ListKeyFingerprints(profileID, username string) ([]string, error) {
	keys, err := fks.GetPublicKeys(profileID, username)
	if err != nil {
		return nil, err
	}

	keyGen := &DefaultKeyGenerator{}
	var fingerprints []string

	for _, publicKey := range keys {
		if fingerprint, err := keyGen.GetFingerprint(publicKey); err == nil {
			fingerprints = append(fingerprints, fingerprint)
		}
	}

	return fingerprints, nil
}

func (fks *FileKeyStore) getPublicKeyPath(profileID, username, keyID string) string {
	return filepath.Join(fks.basePath, "ssh-keys", profileID, username, keyID+".pub")
}

// DefaultKeyGenerator implements KeyGenerator interface
type DefaultKeyGenerator struct{}

// GenerateKeyPair generates a new SSH key pair
func (dkg *DefaultKeyGenerator) GenerateKeyPair(keyType string, keySize int) (privateKey, publicKey []byte, err error) {
	switch keyType {
	case "rsa":
		return dkg.generateRSAKeyPair(keySize)
	case "ed25519":
		return dkg.generateEd25519KeyPair()
	default:
		return nil, nil, fmt.Errorf("unsupported key type: %s", keyType)
	}
}

// generateRSAKeyPair generates an RSA key pair
func (dkg *DefaultKeyGenerator) generateRSAKeyPair(keySize int) (privateKey, publicKey []byte, err error) {
	// Generate RSA private key
	rsaPrivateKey, err := rsa.GenerateKey(rand.Reader, keySize)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to generate RSA private key: %w", err)
	}

	// Encode private key to PEM
	privateKeyBytes := pem.EncodeToMemory(&pem.Block{
		Type:  "RSA PRIVATE KEY",
		Bytes: x509EncodeRSAPrivateKey(rsaPrivateKey), // Placeholder for x509.MarshalPKCS1PrivateKey
	})

	// Generate public key
	rsaPublicKey, err := ssh.NewPublicKey(&rsaPrivateKey.PublicKey)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create SSH public key: %w", err)
	}

	publicKeyBytes := ssh.MarshalAuthorizedKey(rsaPublicKey)

	return privateKeyBytes, publicKeyBytes, nil
}

// generateEd25519KeyPair generates an Ed25519 key pair
func (dkg *DefaultKeyGenerator) generateEd25519KeyPair() (privateKey, publicKey []byte, err error) {
	// Generate Ed25519 key pair
	ed25519PublicKey, ed25519PrivateKey, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to generate Ed25519 key pair: %w", err)
	}

	// Encode private key to PEM
	privateKeyBytes := pem.EncodeToMemory(&pem.Block{
		Type:  "OPENSSH PRIVATE KEY",
		Bytes: marshalEd25519PrivateKey(ed25519PrivateKey), // Placeholder for proper encoding
	})

	// Generate SSH public key
	sshPublicKey, err := ssh.NewPublicKey(ed25519PublicKey)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create SSH public key: %w", err)
	}

	publicKeyBytes := ssh.MarshalAuthorizedKey(sshPublicKey)

	return privateKeyBytes, publicKeyBytes, nil
}

// GetFingerprint returns the SHA256 fingerprint of a public key
func (dkg *DefaultKeyGenerator) GetFingerprint(publicKey []byte) (string, error) {
	// Parse the public key
	parsedKey, _, _, _, err := ssh.ParseAuthorizedKey(publicKey)
	if err != nil {
		return "", fmt.Errorf("failed to parse public key: %w", err)
	}

	// Calculate SHA256 fingerprint
	hash := sha256.Sum256(parsedKey.Marshal())
	fingerprint := base64.StdEncoding.EncodeToString(hash[:])

	return fmt.Sprintf("SHA256:%s", fingerprint), nil
}

// ValidatePublicKey validates that a public key is valid
func (dkg *DefaultKeyGenerator) ValidatePublicKey(publicKey []byte) error {
	_, _, _, _, err := ssh.ParseAuthorizedKey(publicKey)
	if err != nil {
		return fmt.Errorf("invalid public key format: %w", err)
	}
	return nil
}

// Helper functions (placeholders for proper implementations)

func x509EncodeRSAPrivateKey(key *rsa.PrivateKey) []byte {
	// Placeholder for x509.MarshalPKCS1PrivateKey(key)
	// In actual implementation, import "crypto/x509" and use proper encoding
	return []byte("placeholder-rsa-private-key-encoding")
}

func marshalEd25519PrivateKey(key ed25519.PrivateKey) []byte {
	// Placeholder for proper Ed25519 private key encoding
	// In actual implementation, use proper OpenSSH private key format
	return []byte("placeholder-ed25519-private-key-encoding")
}

// ResearchUserSSHManager provides high-level SSH key management for research users
type ResearchUserSSHManager struct {
	sshKeyMgr   *SSHKeyManager
	userManager *ResearchUserManager
}

// NewResearchUserSSHManager creates a new research user SSH manager
func NewResearchUserSSHManager(sshKeyMgr *SSHKeyManager, userMgr *ResearchUserManager) *ResearchUserSSHManager {
	return &ResearchUserSSHManager{
		sshKeyMgr:   sshKeyMgr,
		userManager: userMgr,
	}
}

// SetupSSHKeysForUser sets up SSH keys for a research user
func (rusm *ResearchUserSSHManager) SetupSSHKeysForUser(profileID, username string) error {
	// Get or create research user
	researchUser, err := rusm.userManager.GetOrCreateResearchUser(username)
	if err != nil {
		return fmt.Errorf("failed to get research user: %w", err)
	}

	// Check if user already has SSH keys
	existingKeys, err := rusm.sshKeyMgr.GetPublicKeysForUser(profileID, username)
	if err != nil {
		return fmt.Errorf("failed to get existing keys: %w", err)
	}

	// Generate SSH key pair if none exist
	if len(existingKeys) == 0 {
		keyConfig, privateKey, err := rusm.sshKeyMgr.GenerateSSHKeyPair(profileID, username, "ed25519")
		if err != nil {
			return fmt.Errorf("failed to generate SSH key pair: %w", err)
		}

		// Save private key to user's config (in production, handle this securely)
		fmt.Printf("Generated SSH key pair for %s\n", username)
		fmt.Printf("Private key fingerprint: %s\n", keyConfig.Fingerprint)
		fmt.Printf("Private key length: %d bytes\n", len(privateKey))

		// Update research user with SSH key info
		researchUser.SSHKeyFingerprint = keyConfig.Fingerprint
		researchUser.SSHPublicKeys = []string{keyConfig.PublicKey}

		if err := rusm.userManager.UpdateResearchUser(profileID, researchUser); err != nil {
			return fmt.Errorf("failed to update research user with SSH keys: %w", err)
		}
	}

	return nil
}

// GetSSHKeysForProvisioning gets SSH keys formatted for provisioning scripts
func (rusm *ResearchUserSSHManager) GetSSHKeysForProvisioning(profileID, username string) ([]string, error) {
	keyConfigs, err := rusm.sshKeyMgr.GetPublicKeysForUser(profileID, username)
	if err != nil {
		return nil, fmt.Errorf("failed to get public keys: %w", err)
	}

	var publicKeys []string
	for _, config := range keyConfigs {
		publicKeys = append(publicKeys, config.PublicKey)
	}

	return publicKeys, nil
}
